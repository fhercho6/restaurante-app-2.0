rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    //  REGLA GENERAL PARA COLECCIONES DINMICAS Y RAZ:
    // Solo permitir lectura/escritura si existe en terminales autorizadas.
    match /{document=**} {
      allow read, write: if request.auth != null && exists(/databases/$(database)/documents/allowed_terminals/$(request.auth.uid));
    }

    //  EXCEPCIN: Colecci贸n de Terminales Autorizadas
    // Permitimos a un usuario an贸nimo *crear* o *actualizar* su propio registro 
    // cuando ingresa el c贸digo maestro en la interfaz web (ver Views.jsx).
    match /allowed_terminals/{terminalId} {
      allow read, write: if request.auth != null && request.auth.uid == terminalId;
    }

    //  EXCEPCIONES PBLICAS (Modo Men煤 Digital):
    // El "Modo Clientes" necesita leer el Men煤 y la Configuraci贸n B谩sica sin login.
    
    match /menuItems/{docId} {
        allow read: if true;
        allow write: if request.auth != null && exists(/databases/$(database)/documents/allowed_terminals/$(request.auth.uid));
    }
    
    match /settings/{docId} {
        allow read: if true;
        allow write: if request.auth != null && exists(/databases/$(database)/documents/allowed_terminals/$(request.auth.uid));
    }

    // Support for multi-tenant collections if strictly needed (currently root is used often)
    // If you use prefixes like 'user_XYZ/menuItems', add rules for those too if needed.
    // Based on codebase: const ROOT_COLLECTION = `${currentUser.uid}_`; 
    // The codebase reads `${ROOT_COLLECTION}menuItems`.
    // So we need a recursive match or specific match for the prefixed collections?
    // Firestore rules don't support dynamic collection names easily with wildcards for public access 
    // UNLESS we know the structure.
    //
    // However, the rule `match /{document=**} { allow read: if request.auth != null; }` covers everything else.
    // We need to explicitly allow public read on the specific paths.
    // Since collection names are dynamic (`${uid}_menuItems`), we can't easily hardcode them 
    // unless we use a wildcard match on the collection name itself?
    //
    // NO, we can match specific patterns.
    // match /{collectionName}/{docId} {
    //   allow read: if collectionName.matches('.*menuItems') || collectionName.matches('.*settings');
    // }
    //
    // Let's try that to be robust for the personalized prefixes.
    
    match /{collectionName}/{document=**} {
      allow read: if (request.auth != null && exists(/databases/$(database)/documents/allowed_terminals/$(request.auth.uid))) || collectionName.matches('.*menuItems') || collectionName.matches('.*settings') || collectionName.matches('.*staffMembers');
      allow write: if request.auth != null && exists(/databases/$(database)/documents/allowed_terminals/$(request.auth.uid));
    }
  }
}
