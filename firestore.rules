rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // 游 REGLA GENERAL: 
    // Por defecto, nadie puede leer ni escribir si no est치 autenticado.
    // Esto previene descargas masivas de datos sensibles.
    match /{document=**} {
      allow read, write: if request.auth != null;
    }

    // 游깴 EXCEPCIONES P칔BLICAS (Modo Men칰 Digital):
    // El "Modo Clientes" necesita leer el Men칰 y la Configuraci칩n B치sica sin login.
    
    // 1. Items del Men칰 (Para mostrar productos)
    match /menuItems/{docId} {
        allow read: if true;
        allow write: if request.auth != null;
    }
    
    // 2. Configuraci칩n (Para leer categor칤as, moneda, branding, etc)
    match /settings/{docId} {
        allow read: if true;
        allow write: if request.auth != null;
    }

    // Support for multi-tenant collections if strictly needed (currently root is used often)
    // If you use prefixes like 'user_XYZ/menuItems', add rules for those too if needed.
    // Based on codebase: const ROOT_COLLECTION = `${currentUser.uid}_`; 
    // The codebase reads `${ROOT_COLLECTION}menuItems`.
    // So we need a recursive match or specific match for the prefixed collections?
    // Firestore rules don't support dynamic collection names easily with wildcards for public access 
    // UNLESS we know the structure.
    //
    // However, the rule `match /{document=**} { allow read: if request.auth != null; }` covers everything else.
    // We need to explicitly allow public read on the specific paths.
    // Since collection names are dynamic (`${uid}_menuItems`), we can't easily hardcode them 
    // unless we use a wildcard match on the collection name itself?
    //
    // NO, we can match specific patterns.
    // match /{collectionName}/{docId} {
    //   allow read: if collectionName.matches('.*menuItems') || collectionName.matches('.*settings');
    // }
    //
    // Let's try that to be robust for the personalized prefixes.
    
    match /{collectionName}/{document=**} {
      allow read: if request.auth != null || collectionName.matches('.*menuItems') || collectionName.matches('.*settings');
      allow write: if request.auth != null;
    }
  }
}
